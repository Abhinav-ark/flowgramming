#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const exec_1 = __importDefault(require("./utils/exec"));
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const table_1 = require("table");
const parser_1 = __importDefault(require("./parser"));
const error_1 = __importDefault(require("./error"));
const file_1 = require("./utils/file");
const comment_1 = require("./comment");
const common_1 = require("./utils/common");
const language_1 = require("./language");
const package_json_1 = require("../package.json");
const print_1 = __importDefault(require("./utils/print"));
const parseCommandLineArguments = () => {
    const program = new commander_1.Command();
    program
        .option('-f, --license-file <file>', 'copyright license file')
        .option('-i, --include-path <paths>', "recursively insert header in all files found in path (allows multiple file patterns separated by space and within double quotes '\"')")
        .option('-e, --exclude-path <paths>', "skip adding headers for files in the path (allows multiple file patterns separated by comma space and within double quotes '\"')")
        .option('-u, --include-git-untracked', 'include git untracked files, by default git untracked files will be skipped')
        .option('-s, --git-stage-files', 'add file changes to git staging')
        .option('-ex, --supported-file-extensions', 'list supported file extensions')
        .version(package_json_1.version);
    program.parse(process.argv);
    const options = program.opts();
    return { program, options };
};
(() => __awaiter(void 0, void 0, void 0, function* () {
    const { program, options } = parseCommandLineArguments();
    const supportedFileExtensions = language_1.getSupportedFileExtensions();
    if (options.supportedFileExtensions) {
        print_1.default(`${chalk_1.default.greenBright(supportedFileExtensions.length)} file extensions supported\n${chalk_1.default.yellowBright(supportedFileExtensions.join(', '))}`);
    }
    else if (options.licenseFile || options.includePath) {
        if (!options.licenseFile) {
            print_1.default(chalk_1.default.red('No license file provided\n'));
            program.help({ error: true });
        }
        if (!options) {
            print_1.default(chalk_1.default.red('No paths added for inserting header\n'));
            program.help({ error: true });
        }
        // Check if copyright file exists
        if (!file_1.checkFileExists(options.licenseFile)) {
            print_1.default(chalk_1.default.red('License file not found\n'));
            process.exit(-1);
        }
        // Get all files to include for processing copyright header
        const filesToInclude = yield fast_glob_1.default(common_1.sanitizePath(options.includePath), { dot: true, globstar: true });
        // Get all files to exclude while processing header
        const filesToExclude = yield fast_glob_1.default(options.licenseFile, { dot: true, globstar: true });
        if (options.excludePath) {
            filesToExclude.push(...(yield fast_glob_1.default(common_1.sanitizePath(options.excludePath), { dot: true, globstar: true })));
        }
        // Check if runnning in a git initialized directory
        let gitDirectory = false;
        let commandResult = yield exec_1.default('git rev-parse --is-inside-work-tree');
        if (!commandResult.stderr && commandResult.stdout.includes('true')) {
            gitDirectory = true;
        }
        ;
        const gitTrackedFiles = [];
        if (gitDirectory && !options.includeGitUntracked) {
            // Git tracked files
            commandResult = yield exec_1.default('git ls-tree --full-tree -r --name-only HEAD');
            if (!commandResult.stderr) {
                gitTrackedFiles.push(...common_1.splitIntoLines(commandResult.stdout));
            }
            else {
                throw new Error("Error in getting git tracked files");
            }
            // New files in staging
            commandResult = yield exec_1.default('git diff --staged --name-only');
            if (!commandResult.stderr) {
                gitTrackedFiles.push(...common_1.splitIntoLines(commandResult.stdout));
            }
            else {
                throw new Error("Error in getting git staged files");
            }
        }
        // Filter file list based on files to include, exclude options, file extension and git untracked files
        const filePathList = filesToInclude.filter(filePath => {
            const fileExtension = file_1.getFileExtension(filePath);
            if (!supportedFileExtensions.includes(fileExtension)) {
                return false;
            }
            if (filesToExclude.includes(filePath)) {
                return false;
            }
            if (gitDirectory && !options.includeGitUntracked && !gitTrackedFiles.includes(filePath)) {
                return false;
            }
            return true;
        });
        // Read copyright header from license file
        const copyrightHeader = yield parser_1.default(options.licenseFile);
        copyrightHeader.comment.formatted = common_1.executeJSExpression(copyrightHeader.comment.formatted);
        copyrightHeader.comment.raw = common_1.executeJSExpression(copyrightHeader.comment.raw);
        const finalStat = {
            added: 0,
            updated: 0
        };
        for (const filePath of filePathList) {
            try {
                // Get copyright header from file
                const header = yield parser_1.default(filePath);
                if (!header.comment) {
                    // If doesnt exist, then add copyright header
                    file_1.appendTextToFileBegining(filePath, comment_1.frameCopyrightHeader(copyrightHeader, header.language));
                    print_1.default(`Added copyright license in file ${filePath}`);
                    finalStat.added++;
                }
                else {
                    // Check if current header is same as configured one, if not then replace the header
                    if (header.comment.formatted !== copyrightHeader.comment.formatted) {
                        const result = yield file_1.replaceTextInFile(filePath, header.comment.raw, comment_1.frameCopyrightHeader(copyrightHeader, header.language));
                        print_1.default(`Updated copyright license in file ${filePath}`);
                        finalStat.updated++;
                    }
                }
            }
            catch (err) {
                // Discard unsupported file extension error
                if (!err.message.includes(error_1.default.UNSUPPORTED_FILE_EXTENSION)) {
                    process.exit(-1);
                }
            }
        }
        if (finalStat.added > 0 || finalStat.updated > 0) {
            if (gitDirectory && options.gitStageFiles) {
                commandResult = yield exec_1.default('git add .');
                if (commandResult.stderr) {
                    throw new Error("Error in git staging changes");
                }
            }
            print_1.default(chalk_1.default.greenBright(`\n${'*'.repeat(5)} Summary ${'*'.repeat(5)}`));
            const summary = [
                ['Added', 'Updated'],
                [`${finalStat.added}`, `${finalStat.updated}`]
            ];
            print_1.default(chalk_1.default.greenBright(table_1.table(summary, {
                border: table_1.getBorderCharacters(`ramac`)
            })));
        }
    }
    else {
        program.help();
    }
    process.exit(0);
}))();
//# sourceMappingURL=index.js.map